var documenterSearchIndex = {"docs":
[{"location":"#GenomicBreedingDB","page":"Home","title":"GenomicBreedingDB","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomicBreedingDB.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#GenomicBreedingDB.addfilters!-Tuple{Vector{String}, Vector{Int64}, Vector{Any}}","page":"Home","title":"GenomicBreedingDB.addfilters!","text":"addfilters!(expression::Vector{String}, counter::Vector{Int64}, parameters::Vector{Any}; \n            table::String, values::Union{Vector{String}, Vector{Float64}, Vector{Int64}])::Nothing\n\nAdd SQL LIKE filters to a query expression for pattern matching on table names.\n\nThis function modifies the input vectors to build SQL LIKE conditions for pattern matching, replacing wildcards (*) with SQL wildcards (%) and handling multiple values.\n\nArguments\n\nexpression::Vector{String}: Vector to store SQL query expressions\ncounter::Vector{Int64}: Vector containing a single counter for parameter numbering\nparameters::Vector{Any}: Vector to store parameter values for the query\ntable::String: Name of the database table\nvalues::Union{Vector{String}, Vector{Float64}, Vector{Int64}}: Values to match against table names\n\nEffects\n\nModifies expression by adding LIKE conditions\nIncrements the counter in counter\nAdds values to parameters\n\nReturns\n\nNothing\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.cleaunptraitnames-Tuple{String}","page":"Home","title":"GenomicBreedingDB.cleaunptraitnames","text":"cleaunptraitnames(trait_name::String)::String\n\nClean up trait names by replacing whitespace and special characters with underscores.\n\nArguments\n\ntrait_name::String: The trait name to be cleaned\n\nReturns\n\nString: The cleaned trait name with spaces, tabs and pipe characters replaced with underscores\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.dbconnect-Tuple{}","page":"Home","title":"GenomicBreedingDB.dbconnect","text":"dbconnect()::LibPQ.Connection\n\nEstablishes a connection to a PostgreSQL database using environment variables.\n\nReturns\n\nLibPQ.Connection: A connection object to the PostgreSQL database\n\nEnvironment Variables Required\n\nDB_USER: Database username\nDB_PASSWORD: Database password \nDB_NAME: Name of the database\nDB_HOST: Database host address\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.dbinit","page":"Home","title":"GenomicBreedingDB.dbinit","text":"dbinit(schema_path::String = \"db/schema.sql\")::Nothing\n\nInitialize the database by executing SQL statements from a schema file.\n\nThis function connects to the database, reads SQL statements from the specified schema file, and executes them sequentially. Each statement in the file should be separated by semicolons.\n\nArguments\n\nschema_path::String: Path to the SQL schema file. Defaults to \"db/schema.sql\"\n\nReturns\n\nNothing: Function performs database operations but does not return a value\n\n\n\n\n\n","category":"function"},{"location":"#GenomicBreedingDB.df_to_io-Tuple{Any}","page":"Home","title":"GenomicBreedingDB.df_to_io","text":"df_to_io(df)\n\nConvert a DataFrame to a CSV-formatted byte vector.\n\nTakes a DataFrame df and serializes it to a tab-delimited CSV format in memory. Returns the contents as a Vector{UInt8}.\n\nArguments\n\ndf: The DataFrame to convert to CSV format\n\nReturns\n\nVector{UInt8}: The CSV data as a byte vector\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.extractmainfieldstablesandcols-Tuple{LibPQ.Connection}","page":"Home","title":"GenomicBreedingDB.extractmainfieldstablesandcols","text":"extractmainfieldstablesandcols(conn::LibPQ.Connection)::DataFrame\n\nExtract and sort main field tables and columns from a PostgreSQL database.\n\nThis function queries the information schema of a PostgreSQL database to get table and column names, excluding system tables and specific columns/tables. It then sorts the fields in a predetermined order by temporarily adding prefixes to certain column names.\n\nArguments\n\nconn::LibPQ.Connection: Active PostgreSQL database connection\n\nReturns\n\nDataFrame: A sorted DataFrame with two columns:\ntable_name: Name of the database table\ncolumn_name: Name of the column in the corresponding table\n\nDetails\n\nThe function:\n\nExcludes system schemas ('pgcatalog', 'informationschema')\nExcludes columns ending with 'id'\nExcludes 'description' columns\nExcludes 'traits' and 'phenotype_data' tables\nExcludes tables matching 'analys%s%' pattern\nSorts fields consecutively:   6.1. species  6.2. classification  6.3. name  6.4. population  6.5. year  6.6. season  6.7. harvest  6.8. site  6.9. replication  6.10. block  6.11. row  6.12. col\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.queryanalyses-Tuple{}","page":"Home","title":"GenomicBreedingDB.queryanalyses","text":"queryanalyses(; analyses::Vector{String}, verbose::Bool = false)::DataFrame\n\nQuery and retrieve analysis data from a database, combining information from multiple tables and traits.\n\nArguments\n\nanalyses::Vector{String}: Vector of analysis names to query from the database\nverbose::Bool=false: If true, prints detailed progress information during execution\n\nReturns\n\nDataFrame: A DataFrame containing the combined analysis results with the following:\nStandard fields from the main database tables\nDynamic columns for each trait associated with the requested analyses\nRows grouped by the main fields and aggregated trait values\n\nDetails\n\nThe function performs the following operations:\n\nConnects to the database\nExtracts relevant table and column names\nBuilds a parameterized SQL query that:\nSelects main fields from various tables\nPivots trait values into columns\nJoins multiple tables (analysistags, phenotypedata, entries, traits, trials, layouts, analyses)\nFilters results based on the requested analyses\nGroups and sorts the results\n\nExample\n\nquerytable(\"analyses\")\nqueryanalyses(analyses=[\"analysis_1\"], verbose=true)\nqueryanalyses(analyses=[\"analysis_2\"], verbose=true)\nqueryanalyses(analyses=[\"analysis_3\"], verbose=true)\nqueryanalyses(analyses=[\"analysis_4\"], verbose=true)\nqueryanalyses(analyses=[\"analysis_1\", \"analysis_4\"], verbose=true)\nqueryanalyses(analyses=[\"analysis_3\", \"analysis_4\"], verbose=true)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.querytable-Tuple{String}","page":"Home","title":"GenomicBreedingDB.querytable","text":"querytable(\n    table::String;\n    fields::Union{Missing, Vector{String}} = missing,\n    filters::Union{Missing, Dict{String, Tuple{Int64, Int64}}, Dict{String, Tuple{Float64, Float64}}, Dict{String, Vector{Int64}}, Dict{String, Vector{String}}} = missing,\n)::DataFrame\n\nQuery a PostgreSQL database table and return results as a DataFrame.\n\nArguments\n\ntable::String: Name of the database table to query\nfields::Union{Missing, Vector{String}}: Optional vector of column names to select. If missing, selects all columns (*)\nfilters::Union{Missing, Dict}: Optional dictionary of filter conditions where:\nKeys are column names (String)\nValues can be:\nTuple{Int64,Int64} for BETWEEN conditions\nVector{Int64} for IN conditions with numbers\nVector{String} for IN conditions with strings\n\nReturns\n\nDataFrame: Query results as a DataFrame\n\nExamples\n\nquerytable(\"entries\")\nquerytable(\"traits\")\nquerytable(\"trials\")\nquerytable(\"layouts\")\nquerytable(\"phenotype_data\")\nquerytable(\"analyses\")\nquerytable(\"analysis_tags\")\n\nquerytable(\"phenotype_data\", fields=[\"id\", \"value\"])\nquerytable(\"analyses\", fields=[\"name\", \"description\"])\nquerytable(\"trials\", filters=Dict(\"year\" => [\"2021\", \"2030-2031\"]))\nquerytable(\"layouts\", filters=Dict(\"replication\" => [\"replication_1\"]))\nquerytable(\"phenotype_data\", fields=[\"id\", \"value\"], filters=Dict(\"value\" => (1.0, 10.0)))\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.querytrialsandphenomes-Tuple{}","page":"Home","title":"GenomicBreedingDB.querytrialsandphenomes","text":"querytrialsandphenomes(;\n    traits::Vector{String},\n    species::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    classifications::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    populations::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    entries::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    years::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    seasons::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    harvests::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    sites::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    blocks::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    rows::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    cols::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    replications::Union{Missing,Vector{Union{String, Missing}}, Vector{String}} = missing,\n    sort_rows::Bool = true,\n    verbose::Bool = false,\n)::DataFrame\n\nQuery trials and phenotype data from a database with various filtering options.\n\nArguments\n\ntraits: Vector of trait names to query. Supports wildcards using \"*\".\nspecies: Optional vector of species names to filter by\nclassifications: Optional vector of classification names to filter by\npopulations: Optional vector of population names to filter by  \nentries: Optional vector of entry names to filter by\nyears: Optional vector of years or tuple of (startyear, endyear) to filter by\nseasons: Optional vector of season names to filter by\nharvests: Optional vector of harvest names to filter by\nsites: Optional vector of site names to filter by\nblocks: Optional vector of block names to filter by\nrows: Optional vector of row numbers to filter by\ncols: Optional vector of column numbers to filter by\nreplications: Optional vector of replication numbers to filter by\nsort_rows: Whether to sort the output rows (default: true)\nverbose: Whether to print progress messages (default: false)\n\nReturns\n\nA DataFrame containing the queried trial and phenotype data with columns for all specified fields and traits.\n\nExamples\n\nquerytrialsandphenomes(traits = [\"trait_1\"], verbose=true)\nquerytrialsandphenomes(traits = [\"trait_1\"], classifications=[\"\", missing], entries=[\"entry_01\",\"entry_09\"], verbose=true)\nquerytrialsandphenomes(traits = [\"trait_1\", \"trait_3\"], entries=[\"entry_06\"], verbose=true)\nquerytrialsandphenomes(traits = [\"trait_1\", \"trait_3\"], entries=[\"entry_06\", \"entry_03\"], seasons=[\"season_1\", \"season_4\"], verbose=true)\nquerytrialsandphenomes(traits = [\"trait_1\", \"trait_3\"], entries=[\"entry_06\", \"entry_03\"], seasons=[\"season_3\"], years=[\"2021\"], verbose=true)\nquerytrialsandphenomes(traits = [\"trait_*\"], entries=[\"*1*\"], seasons=[\"Winter\"], years=[\"2030-2031\"], verbose=true)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.updatedescription-Tuple{String}","page":"Home","title":"GenomicBreedingDB.updatedescription","text":"updatedescription(table::String;\n    identifiers::Dict{String, Union{String, Missing}},\n    description::String,\n)::Nothing\n\nUpdate the description field in a specified table based on given identifiers.\n\nArguments\n\ntable::String: The name of the table to update.\nidentifiers::Dict{String, Union{String, Missing}}: A dictionary of column names and their corresponding values to identify the rows to update. Missing values are allowed.\ndescription::String: The new description to set for the matching rows.\n\nThrows\n\nArgumentError: If the table name or any identifier key/value contains a semicolon.\nArgumentError: If the specified table or any identifier column does not exist in the database.\n\nExample\n\nDotEnv.load!(joinpath(homedir(), \".env\"))\nquerytable(\"entries\")\nupdatedescription(\n    \"entries\",\n    identifiers = Dict(\n        \"name\" => \"entry_02\",\n        \"species\" => \"unspecified\",\n        \"population\" => \"pop_1\",\n        \"classification\" => missing,\n    ),\n    description = \"Entry number 2 from population 1 with unspecified species and no additional classification details\",\n)\nquerytable(\"entries\")\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingDB.uploadtrialsorphenomes-Tuple{}","page":"Home","title":"GenomicBreedingDB.uploadtrialsorphenomes","text":"uploadtrialsorphenomes(; fname::String, species::String=\"unspecified\", \n    species_classification::Union{Missing, String}=missing,\n    analysis::Union{Missing, String}=missing,\n    analysis_description::Union{Missing, String}=missing,\n    year::Union{Missing, String}=missing,\n    season::Union{Missing, String}=missing,\n    harvest::Union{Missing, String}=missing,\n    site::Union{Missing, String}=missing,\n    sep::String=\"\\t\",\n    verbose::Bool=false)::Nothing\n\nUpload trial or phenotype data to a database from a delimited file or JLD2 format.\n\nArguments\n\nfname::String: Path to the input file containing trial or phenotype data\nspecies::String: Species name (defaults to \"unspecified\")\nspecies_classification::Union{Missing, String}: Classification of the species\nanalysis::Union{Missing, String}: Name of the analysis if applicable\nanalysis_description::Union{Missing, String}: Description of the analysis\nyear::Union{Missing, String}: Year of the trial/phenotype data which can be \"2023-2024\" for data with seasons spanning two years\nseason::Union{Missing, String}: Season of the trial/phenotype data\nharvest::Union{Missing, String}: Harvest identifier\nsite::Union{Missing, String}: Site location\nsep::String: Delimiter used in the input file (default is tab)\nverbose::Bool: Whether to print additional information during processing\n\nDescription\n\nReads trial or phenotype data from a file and uploads it to a PostgreSQL database. The function can handle both delimited text files and JLD2 format files. It performs the following operations:\n\nReads the input file as either Trials or Phenomes data\nInserts or updates entries in the database tables: entries, traits, trials, layouts\nRecords phenotype data with corresponding relationships\nOptionally adds analysis tags if analysis information is provided\n\nThe function uses SQL transactions to ensure data integrity during the upload process.\n\nReturns\n\nNothing\n\nNote\n\nRequires a properly configured database connection and appropriate table structure in the target database.\n\nExamples\n\ngenomes = GenomicBreedingCore.simulategenomes(n=10, verbose=false)\ntrials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, verbose=false)\ntrials.years = replace.(trials.years, \"year_\" => \"202\")\nfname_trials = writedelimited(trials)\ntebv = analyse(trials, \"y ~ 1|entries\")\nphenomes = merge(merge(tebv.phenomes[1], tebv.phenomes[2]), tebv.phenomes[3])\nfname_phenomes = writedelimited(phenomes)\n\nDotEnv.load!(joinpath(homedir(), \".env\"))\nuploadtrialsorphenomes(fname=fname_trials, verbose=true)\nuploadtrialsorphenomes(fname=fname_phenomes, verbose=true)\nuploadtrialsorphenomes(fname=fname_trials, analysis=\"analysis_1\", verbose=true)\nuploadtrialsorphenomes(fname=fname_trials, analysis=\"analysis_2\", analysis_description=\"some description\", verbose=true)\nuploadtrialsorphenomes(fname=fname_phenomes, analysis=\"analysis_3\", verbose=true)\nuploadtrialsorphenomes(fname=fname_phenomes, analysis=\"analysis_4\", year=\"2030-2031\", season=\"Winter\", verbose=true)\n\n\n\n\n\n","category":"method"}]
}
